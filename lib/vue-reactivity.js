/**
 * Minified by jsDelivr using Terser v5.19.2.
 * Original file: /npm/@vue/reactivity@3.5.13/dist/reactivity.global.js
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
var VueReactivity = function (e) {
    "use strict";
    /*! #__NO_SIDE_EFFECTS__ */function t(e) { const t = Object.create(null); for (const s of e.split(",")) t[s] = 1; return e => e in t } const s = Object.freeze({}), n = () => { }, i = Object.assign, r = Object.prototype.hasOwnProperty, o = (e, t) => r.call(e, t), a = Array.isArray, c = e => "[object Map]" === d(e), u = e => "[object Set]" === d(e), l = e => "function" == typeof e, f = e => "symbol" == typeof e, h = e => null !== e && "object" == typeof e, p = Object.prototype.toString, d = e => p.call(e), v = e => d(e).slice(8, -1), _ = e => "[object Object]" === d(e), g = e => "string" == typeof e && "NaN" !== e && "-" !== e[0] && "" + parseInt(e, 10) === e, y = (e => { const t = Object.create(null); return s => t[s] || (t[s] = e(s)) })((e => e.charAt(0).toUpperCase() + e.slice(1))), b = (e, t) => !Object.is(e, t); function w(e, ...t) { console.warn(`[Vue warn] ${e}`, ...t) } let R, S; class k { constructor(e = !1) { this.detached = e, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = R, !e && R && (this.index = (R.scopes || (R.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { let e, t; if (this._isPaused = !0, this.scopes) for (e = 0, t = this.scopes.length; e < t; e++)this.scopes[e].pause(); for (e = 0, t = this.effects.length; e < t; e++)this.effects[e].pause() } } resume() { if (this._active && this._isPaused) { let e, t; if (this._isPaused = !1, this.scopes) for (e = 0, t = this.scopes.length; e < t; e++)this.scopes[e].resume(); for (e = 0, t = this.effects.length; e < t; e++)this.effects[e].resume() } } run(e) { if (this._active) { const t = R; try { return R = this, e() } finally { R = t } } else w("cannot run an inactive effect scope.") } on() { R = this } off() { R = this.parent } stop(e) { if (this._active) { let t, s; for (this._active = !1, t = 0, s = this.effects.length; t < s; t++)this.effects[t].stop(); for (this.effects.length = 0, t = 0, s = this.cleanups.length; t < s; t++)this.cleanups[t](); if (this.cleanups.length = 0, this.scopes) { for (t = 0, s = this.scopes.length; t < s; t++)this.scopes[t].stop(!0); this.scopes.length = 0 } if (!this.detached && this.parent && !e) { const e = this.parent.scopes.pop(); e && e !== this && (this.parent.scopes[this.index] = e, e.index = this.index) } this.parent = void 0 } } } function T() { return R } const x = new WeakSet; class m { constructor(e) { this.fn = e, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, R && R.active && R.effects.push(this) } pause() { this.flags |= 64 } resume() { 64 & this.flags && (this.flags &= -65, x.has(this) && (x.delete(this), this.trigger())) } notify() { 2 & this.flags && !(32 & this.flags) || 8 & this.flags || O(this) } run() { if (!(1 & this.flags)) return this.fn(); this.flags |= 2, U(this), L(this); const e = S, t = H; S = this, H = !0; try { return this.fn() } finally { S !== this && w("Active effect was not restored correctly - this is likely a Vue internal bug."), C(this), S = e, H = t, this.flags &= -3 } } stop() { if (1 & this.flags) { for (let e = this.deps; e; e = e.nextDep)V(e); this.deps = this.depsTail = void 0, U(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { 64 & this.flags ? x.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { P(this) && this.run() } get dirty() { return P(this) } } let E, A, D = 0; function O(e, t = !1) { if (e.flags |= 8, t) return e.next = A, void (A = e); e.next = E, E = e } function I() { D++ } function j() { if (--D > 0) return; if (A) { let e = A; for (A = void 0; e;) { const t = e.next; e.next = void 0, e.flags &= -9, e = t } } let e; for (; E;) { let t = E; for (E = void 0; t;) { const s = t.next; if (t.next = void 0, t.flags &= -9, 1 & t.flags) try { t.trigger() } catch (t) { e || (e = t) } t = s } } if (e) throw e } function L(e) { for (let t = e.deps; t; t = t.nextDep)t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t } function C(e) { let t, s = e.depsTail, n = s; for (; n;) { const e = n.prevDep; -1 === n.version ? (n === s && (s = e), V(n), N(n)) : t = n, n.dep.activeLink = n.prevActiveLink, n.prevActiveLink = void 0, n = e } e.deps = t, e.depsTail = s } function P(e) { for (let t = e.deps; t; t = t.nextDep)if (t.dep.version !== t.version || t.dep.computed && (W(t.dep.computed) || t.dep.version !== t.version)) return !0; return !!e._dirty } function W(e) { if (4 & e.flags && !(16 & e.flags)) return; if (e.flags &= -17, e.globalVersion === Y) return; e.globalVersion = Y; const t = e.dep; if (e.flags |= 2, t.version > 0 && !e.isSSR && e.deps && !P(e)) return void (e.flags &= -3); const s = S, n = H; S = e, H = !0; try { L(e); const s = e.fn(e._value); (0 === t.version || b(s, e._value)) && (e._value = s, t.version++) } catch (e) { throw t.version++, e } finally { S = s, H = n, C(e), e.flags &= -3 } } function V(e, t = !1) { const { dep: s, prevSub: n, nextSub: i } = e; if (n && (n.nextSub = i, e.prevSub = void 0), i && (i.prevSub = n, e.nextSub = void 0), s.subsHead === e && (s.subsHead = i), s.subs === e && (s.subs = n, !n && s.computed)) { s.computed.flags &= -5; for (let e = s.computed.deps; e; e = e.nextDep)V(e, !0) } t || --s.sc || !s.map || s.map.delete(s.key) } function N(e) { const { prevDep: t, nextDep: s } = e; t && (t.nextDep = s, e.prevDep = void 0), s && (s.prevDep = t, e.nextDep = void 0) } let H = !0; const M = []; function K() { M.push(H), H = !1 } function $() { const e = M.pop(); H = void 0 === e || e } function U(e) { const { cleanup: t } = e; if (e.cleanup = void 0, t) { const e = S; S = void 0; try { t() } finally { S = e } } } let Y = 0; class G { constructor(e, t) { this.sub = e, this.dep = t, this.version = t.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } } class F { constructor(e) { this.computed = e, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0, this.subsHead = void 0 } track(e) { if (!S || !H || S === this.computed) return; let t = this.activeLink; if (void 0 === t || t.sub !== S) t = this.activeLink = new G(S, this), S.deps ? (t.prevDep = S.depsTail, S.depsTail.nextDep = t, S.depsTail = t) : S.deps = S.depsTail = t, z(t); else if (-1 === t.version && (t.version = this.version, t.nextDep)) { const e = t.nextDep; e.prevDep = t.prevDep, t.prevDep && (t.prevDep.nextDep = e), t.prevDep = S.depsTail, t.nextDep = void 0, S.depsTail.nextDep = t, S.depsTail = t, S.deps === t && (S.deps = e) } return S.onTrack && S.onTrack(i({ effect: S }, e)), t } trigger(e) { this.version++, Y++, this.notify(e) } notify(e) { I(); try { for (let t = this.subsHead; t; t = t.nextSub)!t.sub.onTrigger || 8 & t.sub.flags || t.sub.onTrigger(i({ effect: t.sub }, e)); for (let e = this.subs; e; e = e.prevSub)e.sub.notify() && e.sub.dep.notify() } finally { j() } } } function z(e) { if (e.dep.sc++, 4 & e.sub.flags) { const t = e.dep.computed; if (t && !e.dep.subs) { t.flags |= 20; for (let e = t.deps; e; e = e.nextDep)z(e) } const s = e.dep.subs; s !== e && (e.prevSub = s, s && (s.nextSub = e)), void 0 === e.dep.subsHead && (e.dep.subsHead = e), e.dep.subs = e } } const B = new WeakMap, J = Symbol("Object iterate"), q = Symbol("Map keys iterate"), Q = Symbol("Array iterate"); function X(e, t, s) { if (H && S) { let n = B.get(e); n || B.set(e, n = new Map); let i = n.get(s); i || (n.set(s, i = new F), i.map = n, i.key = s), i.track({ target: e, type: t, key: s }) } } function Z(e, t, s, n, i, r) { const o = B.get(e); if (!o) return void Y++; const u = o => { o && o.trigger({ target: e, type: t, key: s, newValue: n, oldValue: i, oldTarget: r }) }; if (I(), "clear" === t) o.forEach(u); else { const i = a(e), r = i && g(s); if (i && "length" === s) { const e = Number(n); o.forEach(((t, s) => { ("length" === s || s === Q || !f(s) && s >= e) && u(t) })) } else switch ((void 0 !== s || o.has(void 0)) && u(o.get(s)), r && u(o.get(Q)), t) { case "add": i ? r && u(o.get("length")) : (u(o.get(J)), c(e) && u(o.get(q))); break; case "delete": i || (u(o.get(J)), c(e) && u(o.get(q))); break; case "set": c(e) && u(o.get(J)) } } j() } function ee(e) { const t = Me(e); return t === e ? t : (X(t, "iterate", Q), Ne(e) ? t : t.map(Ke)) } function te(e) { return X(e = Me(e), "iterate", Q), e } const se = { __proto__: null, [Symbol.iterator]() { return ne(this, Symbol.iterator, Ke) }, concat(...e) { return ee(this).concat(...e.map((e => a(e) ? ee(e) : e))) }, entries() { return ne(this, "entries", (e => (e[1] = Ke(e[1]), e))) }, every(e, t) { return re(this, "every", e, t, void 0, arguments) }, filter(e, t) { return re(this, "filter", e, t, (e => e.map(Ke)), arguments) }, find(e, t) { return re(this, "find", e, t, Ke, arguments) }, findIndex(e, t) { return re(this, "findIndex", e, t, void 0, arguments) }, findLast(e, t) { return re(this, "findLast", e, t, Ke, arguments) }, findLastIndex(e, t) { return re(this, "findLastIndex", e, t, void 0, arguments) }, forEach(e, t) { return re(this, "forEach", e, t, void 0, arguments) }, includes(...e) { return ae(this, "includes", e) }, indexOf(...e) { return ae(this, "indexOf", e) }, join(e) { return ee(this).join(e) }, lastIndexOf(...e) { return ae(this, "lastIndexOf", e) }, map(e, t) { return re(this, "map", e, t, void 0, arguments) }, pop() { return ce(this, "pop") }, push(...e) { return ce(this, "push", e) }, reduce(e, ...t) { return oe(this, "reduce", e, t) }, reduceRight(e, ...t) { return oe(this, "reduceRight", e, t) }, shift() { return ce(this, "shift") }, some(e, t) { return re(this, "some", e, t, void 0, arguments) }, splice(...e) { return ce(this, "splice", e) }, toReversed() { return ee(this).toReversed() }, toSorted(e) { return ee(this).toSorted(e) }, toSpliced(...e) { return ee(this).toSpliced(...e) }, unshift(...e) { return ce(this, "unshift", e) }, values() { return ne(this, "values", Ke) } }; function ne(e, t, s) { const n = te(e), i = n[t](); return n === e || Ne(e) || (i._next = i.next, i.next = () => { const e = i._next(); return e.value && (e.value = s(e.value)), e }), i } const ie = Array.prototype; function re(e, t, s, n, i, r) { const o = te(e), a = o !== e && !Ne(e), c = o[t]; if (c !== ie[t]) { const t = c.apply(e, r); return a ? Ke(t) : t } let u = s; o !== e && (a ? u = function (t, n) { return s.call(this, Ke(t), n, e) } : s.length > 2 && (u = function (t, n) { return s.call(this, t, n, e) })); const l = c.call(o, u, n); return a && i ? i(l) : l } function oe(e, t, s, n) { const i = te(e); let r = s; return i !== e && (Ne(e) ? s.length > 3 && (r = function (t, n, i) { return s.call(this, t, n, i, e) }) : r = function (t, n, i) { return s.call(this, t, Ke(n), i, e) }), i[t](r, ...n) } function ae(e, t, s) { const n = Me(e); X(n, "iterate", Q); const i = n[t](...s); return -1 !== i && !1 !== i || !He(s[0]) ? i : (s[0] = Me(s[0]), n[t](...s)) } function ce(e, t, s = []) { K(), I(); const n = Me(e)[t].apply(e, s); return j(), $(), n } const ue = t("__proto__,__v_isRef,__isVue"), le = new Set(Object.getOwnPropertyNames(Symbol).filter((e => "arguments" !== e && "caller" !== e)).map((e => Symbol[e])).filter(f)); function fe(e) { f(e) || (e = String(e)); const t = Me(this); return X(t, "has", e), t.hasOwnProperty(e) } class he { constructor(e = !1, t = !1) { this._isReadonly = e, this._isShallow = t } get(e, t, s) { if ("__v_skip" === t) return e.__v_skip; const n = this._isReadonly, i = this._isShallow; if ("__v_isReactive" === t) return !n; if ("__v_isReadonly" === t) return n; if ("__v_isShallow" === t) return i; if ("__v_raw" === t) return s === (n ? i ? je : Ie : i ? Oe : De).get(e) || Object.getPrototypeOf(e) === Object.getPrototypeOf(s) ? e : void 0; const r = a(e); if (!n) { let e; if (r && (e = se[t])) return e; if ("hasOwnProperty" === t) return fe } const o = Reflect.get(e, t, Ue(e) ? e : s); return (f(t) ? le.has(t) : ue(t)) ? o : (n || X(e, "get", t), i ? o : Ue(o) ? r && g(t) ? o : o.value : h(o) ? n ? Ce(o) : Le(o) : o) } } class pe extends he { constructor(e = !1) { super(!1, e) } set(e, t, s, n) { let i = e[t]; if (!this._isShallow) { const t = Ve(i); if (Ne(s) || Ve(s) || (i = Me(i), s = Me(s)), !a(e) && Ue(i) && !Ue(s)) return !t && (i.value = s, !0) } const r = a(e) && g(t) ? Number(t) < e.length : o(e, t), c = Reflect.set(e, t, s, Ue(e) ? e : n); return e === Me(n) && (r ? b(s, i) && Z(e, "set", t, s, i) : Z(e, "add", t, s)), c } deleteProperty(e, t) { const s = o(e, t), n = e[t], i = Reflect.deleteProperty(e, t); return i && s && Z(e, "delete", t, void 0, n), i } has(e, t) { const s = Reflect.has(e, t); return f(t) && le.has(t) || X(e, "has", t), s } ownKeys(e) { return X(e, "iterate", a(e) ? "length" : J), Reflect.ownKeys(e) } } class de extends he { constructor(e = !1) { super(!0, e) } set(e, t) { return w(`Set operation on key "${String(t)}" failed: target is readonly.`, e), !0 } deleteProperty(e, t) { return w(`Delete operation on key "${String(t)}" failed: target is readonly.`, e), !0 } } const ve = new pe, _e = new de, ge = new pe(!0), ye = new de(!0), be = e => e, we = e => Reflect.getPrototypeOf(e); function Re(e) { return function (...t) { { const s = t[0] ? `on key "${t[0]}" ` : ""; w(`${y(e)} operation ${s}failed: target is readonly.`, Me(this)) } return "delete" !== e && ("clear" === e ? void 0 : this) } } function Se(e, t) { const s = { get(s) { const n = this.__v_raw, i = Me(n), r = Me(s); e || (b(s, r) && X(i, "get", s), X(i, "get", r)); const { has: o } = we(i), a = t ? be : e ? $e : Ke; return o.call(i, s) ? a(n.get(s)) : o.call(i, r) ? a(n.get(r)) : void (n !== i && n.get(s)) }, get size() { const t = this.__v_raw; return !e && X(Me(t), "iterate", J), Reflect.get(t, "size", t) }, has(t) { const s = this.__v_raw, n = Me(s), i = Me(t); return e || (b(t, i) && X(n, "has", t), X(n, "has", i)), t === i ? s.has(t) : s.has(t) || s.has(i) }, forEach(s, n) { const i = this, r = i.__v_raw, o = Me(r), a = t ? be : e ? $e : Ke; return !e && X(o, "iterate", J), r.forEach(((e, t) => s.call(n, a(e), a(t), i))) } }; i(s, e ? { add: Re("add"), set: Re("set"), delete: Re("delete"), clear: Re("clear") } : { add(e) { t || Ne(e) || Ve(e) || (e = Me(e)); const s = Me(this); return we(s).has.call(s, e) || (s.add(e), Z(s, "add", e, e)), this }, set(e, s) { t || Ne(s) || Ve(s) || (s = Me(s)); const n = Me(this), { has: i, get: r } = we(n); let o = i.call(n, e); o ? Ae(n, i, e) : (e = Me(e), o = i.call(n, e)); const a = r.call(n, e); return n.set(e, s), o ? b(s, a) && Z(n, "set", e, s, a) : Z(n, "add", e, s), this }, delete(e) { const t = Me(this), { has: s, get: n } = we(t); let i = s.call(t, e); i ? Ae(t, s, e) : (e = Me(e), i = s.call(t, e)); const r = n ? n.call(t, e) : void 0, o = t.delete(e); return i && Z(t, "delete", e, void 0, r), o }, clear() { const e = Me(this), t = 0 !== e.size, s = c(e) ? new Map(e) : new Set(e), n = e.clear(); return t && Z(e, "clear", void 0, void 0, s), n } }); return ["keys", "values", "entries", Symbol.iterator].forEach((n => { s[n] = function (e, t, s) { return function (...n) { const i = this.__v_raw, r = Me(i), o = c(r), a = "entries" === e || e === Symbol.iterator && o, u = "keys" === e && o, l = i[e](...n), f = s ? be : t ? $e : Ke; return !t && X(r, "iterate", u ? q : J), { next() { const { value: e, done: t } = l.next(); return t ? { value: e, done: t } : { value: a ? [f(e[0]), f(e[1])] : f(e), done: t } }, [Symbol.iterator]() { return this } } } }(n, e, t) })), s } function ke(e, t) { const s = Se(e, t); return (t, n, i) => "__v_isReactive" === n ? !e : "__v_isReadonly" === n ? e : "__v_raw" === n ? t : Reflect.get(o(s, n) && n in t ? s : t, n, i) } const Te = { get: ke(!1, !1) }, xe = { get: ke(!1, !0) }, me = { get: ke(!0, !1) }, Ee = { get: ke(!0, !0) }; function Ae(e, t, s) { const n = Me(s); if (n !== s && t.call(e, n)) { const t = v(e); w(`Reactive ${t} contains both the raw and reactive versions of the same object${"Map" === t ? " as keys" : ""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`) } } const De = new WeakMap, Oe = new WeakMap, Ie = new WeakMap, je = new WeakMap; function Le(e) { return Ve(e) ? e : Pe(e, !1, ve, Te, De) } function Ce(e) { return Pe(e, !0, _e, me, Ie) } function Pe(e, t, s, n, i) { if (!h(e)) return w(`value cannot be made ${t ? "readonly" : "reactive"}: ${String(e)}`), e; if (e.__v_raw && (!t || !e.__v_isReactive)) return e; const r = i.get(e); if (r) return r; const o = (a = e).__v_skip || !Object.isExtensible(a) ? 0 : function (e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } }(v(a)); var a; if (0 === o) return e; const c = new Proxy(e, 2 === o ? n : s); return i.set(e, c), c } function We(e) { return Ve(e) ? We(e.__v_raw) : !(!e || !e.__v_isReactive) } function Ve(e) { return !(!e || !e.__v_isReadonly) } function Ne(e) { return !(!e || !e.__v_isShallow) } function He(e) { return !!e && !!e.__v_raw } function Me(e) { const t = e && e.__v_raw; return t ? Me(t) : e } const Ke = e => h(e) ? Le(e) : e, $e = e => h(e) ? Ce(e) : e; function Ue(e) { return !!e && !0 === e.__v_isRef } function Ye(e) { return Ge(e, !1) } function Ge(e, t) { return Ue(e) ? e : new Fe(e, t) } class Fe { constructor(e, t) { this.dep = new F, this.__v_isRef = !0, this.__v_isShallow = !1, this._rawValue = t ? e : Me(e), this._value = t ? e : Ke(e), this.__v_isShallow = t } get value() { return this.dep.track({ target: this, type: "get", key: "value" }), this._value } set value(e) { const t = this._rawValue, s = this.__v_isShallow || Ne(e) || Ve(e); e = s ? e : Me(e), b(e, t) && (this._rawValue = e, this._value = s ? e : Ke(e), this.dep.trigger({ target: this, type: "set", key: "value", newValue: e, oldValue: t })) } } function ze(e) { return Ue(e) ? e.value : e } const Be = { get: (e, t, s) => "__v_raw" === t ? e : ze(Reflect.get(e, t, s)), set: (e, t, s, n) => { const i = e[t]; return Ue(i) && !Ue(s) ? (i.value = s, !0) : Reflect.set(e, t, s, n) } }; class Je { constructor(e) { this.__v_isRef = !0, this._value = void 0; const t = this.dep = new F, { get: s, set: n } = e(t.track.bind(t), t.trigger.bind(t)); this._get = s, this._set = n } get value() { return this._value = this._get() } set value(e) { this._set(e) } } class qe { constructor(e, t, s) { this._object = e, this._key = t, this._defaultValue = s, this.__v_isRef = !0, this._value = void 0 } get value() { const e = this._object[this._key]; return this._value = void 0 === e ? this._defaultValue : e } set value(e) { this._object[this._key] = e } get dep() { return function (e, t) { const s = B.get(e); return s && s.get(t) }(Me(this._object), this._key) } } class Qe { constructor(e) { this._getter = e, this.__v_isRef = !0, this.__v_isReadonly = !0, this._value = void 0 } get value() { return this._value = this._getter() } } function Xe(e, t, s) { const n = e[t]; return Ue(n) ? n : new qe(e, t, s) } class Ze { constructor(e, t, s) { this.fn = e, this.setter = t, this._value = void 0, this.dep = new F(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Y - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !t, this.isSSR = s } notify() { if (this.flags |= 16, !(8 & this.flags) && S !== this) return O(this, !0), !0 } get value() { const e = this.dep.track({ target: this, type: "get", key: "value" }); return W(this), e && (e.version = this.dep.version), this._value } set value(e) { this.setter ? this.setter(e) : w("Write operation failed: computed value is readonly") } } const et = {}, tt = new WeakMap; let st; function nt(e, t = !1, s = st) { if (s) { let t = tt.get(s); t || tt.set(s, t = []), t.push(e) } else t || w("onWatcherCleanup() was called when there was no active watcher to associate with.") } function it(e, t = 1 / 0, s) { if (t <= 0 || !h(e) || e.__v_skip) return e; if ((s = s || new Set).has(e)) return e; if (s.add(e), t--, Ue(e)) it(e.value, t, s); else if (a(e)) for (let n = 0; n < e.length; n++)it(e[n], t, s); else if (u(e) || c(e)) e.forEach((e => { it(e, t, s) })); else if (_(e)) { for (const n in e) it(e[n], t, s); for (const n of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, n) && it(e[n], t, s) } return e } return e.ARRAY_ITERATE_KEY = Q, e.EffectFlags = { ACTIVE: 1, 1: "ACTIVE", RUNNING: 2, 2: "RUNNING", TRACKING: 4, 4: "TRACKING", NOTIFIED: 8, 8: "NOTIFIED", DIRTY: 16, 16: "DIRTY", ALLOW_RECURSE: 32, 32: "ALLOW_RECURSE", PAUSED: 64, 64: "PAUSED" }, e.EffectScope = k, e.ITERATE_KEY = J, e.MAP_KEY_ITERATE_KEY = q, e.ReactiveEffect = m, e.ReactiveFlags = { SKIP: "__v_skip", IS_REACTIVE: "__v_isReactive", IS_READONLY: "__v_isReadonly", IS_SHALLOW: "__v_isShallow", RAW: "__v_raw", IS_REF: "__v_isRef" }, e.TrackOpTypes = { GET: "get", HAS: "has", ITERATE: "iterate" }, e.TriggerOpTypes = { SET: "set", ADD: "add", DELETE: "delete", CLEAR: "clear" }, e.WatchErrorCodes = { WATCH_GETTER: 2, 2: "WATCH_GETTER", WATCH_CALLBACK: 3, 3: "WATCH_CALLBACK", WATCH_CLEANUP: 4, 4: "WATCH_CLEANUP" }, e.computed = function (e, t, s = !1) { let n, i; l(e) ? n = e : (n = e.get, i = e.set); const r = new Ze(n, i, s); return t && !s && (r.onTrack = t.onTrack, r.onTrigger = t.onTrigger), r }, e.customRef = function (e) { return new Je(e) }, e.effect = function (e, t) { e.effect instanceof m && (e = e.effect.fn); const s = new m(e); t && i(s, t); try { s.run() } catch (e) { throw s.stop(), e } const n = s.run.bind(s); return n.effect = s, n }, e.effectScope = function (e) { return new k(e) }, e.enableTracking = function () { M.push(H), H = !0 }, e.getCurrentScope = T, e.getCurrentWatcher = function () { return st }, e.isProxy = He, e.isReactive = We, e.isReadonly = Ve, e.isRef = Ue, e.isShallow = Ne, e.markRaw = function (e) { return !o(e, "__v_skip") && Object.isExtensible(e) && ((e, t, s, n = !1) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: n, value: s }) })(e, "__v_skip", !0), e }, e.onEffectCleanup = function (e, t = !1) { S instanceof m ? S.cleanup = e : t || w("onEffectCleanup() was called when there was no active effect to associate with.") }, e.onScopeDispose = function (e, t = !1) { R ? R.cleanups.push(e) : t || w("onScopeDispose() is called when there is no active effect scope to be associated with.") }, e.onWatcherCleanup = nt, e.pauseTracking = K, e.proxyRefs = function (e) { return We(e) ? e : new Proxy(e, Be) }, e.reactive = Le, e.reactiveReadArray = ee, e.readonly = Ce, e.ref = Ye, e.resetTracking = $, e.shallowReactive = function (e) { return Pe(e, !1, ge, xe, Oe) }, e.shallowReadArray = te, e.shallowReadonly = function (e) { return Pe(e, !0, ye, Ee, je) }, e.shallowRef = function (e) { return Ge(e, !0) }, e.stop = function (e) { e.effect.stop() }, e.toRaw = Me, e.toReactive = Ke, e.toReadonly = $e, e.toRef = function (e, t, s) { return Ue(e) ? e : l(e) ? new Qe(e) : h(e) && arguments.length > 1 ? Xe(e, t, s) : Ye(e) }, e.toRefs = function (e) { He(e) || w("toRefs() expects a reactive object but received a plain one."); const t = a(e) ? new Array(e.length) : {}; for (const s in e) t[s] = Xe(e, s); return t }, e.toValue = function (e) { return l(e) ? e() : ze(e) }, e.track = X, e.traverse = it, e.trigger = Z, e.triggerRef = function (e) { e.dep && e.dep.trigger({ target: e, type: "set", key: "value", newValue: e._value }) }, e.unref = ze, e.watch = function (e, t, i = s) { const { immediate: r, deep: o, once: c, scheduler: u, augmentJob: f, call: h } = i, p = e => { (i.onWarn || w)("Invalid watch source: ", e, "A watch source can only be a getter/effect function, a ref, a reactive object, or an array of these types.") }, d = e => o ? e : Ne(e) || !1 === o || 0 === o ? it(e, 1) : it(e); let v, _, g, y, R = !1, S = !1; if (Ue(e) ? (_ = () => e.value, R = Ne(e)) : We(e) ? (_ = () => d(e), R = !0) : a(e) ? (S = !0, R = e.some((e => We(e) || Ne(e))), _ = () => e.map((e => Ue(e) ? e.value : We(e) ? d(e) : l(e) ? h ? h(e, 2) : e() : void p(e)))) : l(e) ? _ = t ? h ? () => h(e, 2) : e : () => { if (g) { K(); try { g() } finally { $() } } const t = st; st = v; try { return h ? h(e, 3, [y]) : e(y) } finally { st = t } } : (_ = n, p(e)), t && o) { const e = _, t = !0 === o ? 1 / 0 : o; _ = () => it(e(), t) } const k = T(), x = () => { v.stop(), k && k.active && ((e, t) => { const s = e.indexOf(t); s > -1 && e.splice(s, 1) })(k.effects, v) }; if (c && t) { const e = t; t = (...t) => { e(...t), x() } } let E = S ? new Array(e.length).fill(et) : et; const A = e => { if (1 & v.flags && (v.dirty || e)) if (t) { const e = v.run(); if (o || R || (S ? e.some(((e, t) => b(e, E[t]))) : b(e, E))) { g && g(); const s = st; st = v; try { const s = [e, E === et ? void 0 : S && E[0] === et ? [] : E, y]; h ? h(t, 3, s) : t(...s), E = e } finally { st = s } } } else v.run() }; return f && f(A), v = new m(_), v.scheduler = u ? () => u(A, !1) : A, y = e => nt(e, !1, v), g = v.onStop = () => { const e = tt.get(v); if (e) { if (h) h(e, 4); else for (const t of e) t(); tt.delete(v) } }, v.onTrack = i.onTrack, v.onTrigger = i.onTrigger, t ? r ? A(!0) : E = v.run() : u ? u(A.bind(null, !0), !0) : v.run(), x.pause = v.pause.bind(v), x.resume = v.resume.bind(v), x.stop = x, x }, e
}({});
//# sourceMappingURL=/sm/7744d1788f399c6069de2f3c38f529b4dcddf47ef9303c564f88a714c9c4e8ea.map